---
title: Regras de segurança (análise de código)
description: Saiba mais sobre as regras de segurança da análise de código.
ms.date: 10/02/2019
ms.topic: reference
f1_keywords:
- vs.codeanalysis.securityrules
helpviewer_keywords:
- security [Visual Studio ALM], Enterprise Templates
- security rules
- managed code analysis rules, security rules
- rules, security
author: gewarren
ms.author: gewarren
ms.openlocfilehash: e907905b065d786fc8b3c370fb2d2e2b19e62a2b
ms.sourcegitcommit: 5114e7847e0ff8ddb8c266802d47af78567949cf
ms.translationtype: MT
ms.contentlocale: pt-BR
ms.lasthandoff: 11/19/2020
ms.locfileid: "96585625"
---
# <a name="security-rules"></a>Regras de segurança

As regras de segurança dão suporte a bibliotecas e aplicativos mais seguros. Essas regras ajudam a evitar falhas de segurança em seu programa. Se você desabilitar qualquer uma dessas regras, deverá marcar claramente o motivo no código e também informar o diretor de segurança designado para seu projeto de desenvolvimento.

## <a name="in-this-section"></a>Nesta seção

|Regra|Descrição|
|----------|-----------------|
|[CA2100: Examinar consultas SQL em busca de vulnerabilidades de segurança](ca2100.md)|Um método define a propriedade System.Data.IDbCommand.CommandText usando uma cadeia de caracteres criada com base em um argumento da cadeia de caracteres para o método. Esta regra pressupõe que o argumento da cadeia de caracteres contenha a entrada do usuário. Uma cadeia de caracteres de comando SQL criada com base na entrada do usuário é vulnerável a ataques de injeção SQL.|
|[CA2109: Examinar manipuladores de eventos visíveis](ca2109.md)|Um método público ou protegido de tratamento de eventos foi detectado. Os métodos de tratamento de eventos não devem ser expostos, a menos que seja absolutamente necessário.|
|[CA2119: Selar métodos que atendem a interfaces particulares](ca2119.md)|Um tipo público herdável fornece uma implementação de método substituível de uma interface (Friend no Visual Basic) interna. Para corrigir uma violação dessa regra, evite que o método seja substituído fora do assembly.|
|[CA2153: Evite lidar com exceções de estado corrompido](ca2153.md)|As [exceções de estado corrompidas (CSE)](/archive/msdn-magazine/2009/february/clr-inside-out-handling-corrupted-state-exceptions) indicam que há corrupção de memória em seu processo. A captura deles, em vez de permitir que o processo falhe, pode levar a vulnerabilidades de segurança se um invasor puder fazer uma exploração na região de memória corrompida.|
|[CA2300: Não usar o desserializador BinaryFormatter não seguro](ca2300.md)|Desserializadores inseguros são vulneráveis ao desserializar dados não confiáveis. Um invasor pode modificar os dados serializados para incluir tipos inesperados para injetar objetos com efeitos colaterais mal-intencionados.|
|[CA2301: Não chamar BinaryFormatter.Deserialize sem antes definir BinaryFormatter.Binder](ca2301.md)|Desserializadores inseguros são vulneráveis ao desserializar dados não confiáveis. Um invasor pode modificar os dados serializados para incluir tipos inesperados para injetar objetos com efeitos colaterais mal-intencionados.|
|[CA2302: Verificar se o BinaryFormatter.Binder está definido antes de chamar BinaryFormatter.Deserialize](ca2302.md)|Desserializadores inseguros são vulneráveis ao desserializar dados não confiáveis. Um invasor pode modificar os dados serializados para incluir tipos inesperados para injetar objetos com efeitos colaterais mal-intencionados.|
|[CA2305: Não usar o desserializador inseguro LosFormatter](ca2305.md)|Desserializadores inseguros são vulneráveis ao desserializar dados não confiáveis. Um invasor pode modificar os dados serializados para incluir tipos inesperados para injetar objetos com efeitos colaterais mal-intencionados.|
|[CA2310: Não usar o desserializador inseguro NetDataContractSerializer](ca2310.md)|Desserializadores inseguros são vulneráveis ao desserializar dados não confiáveis. Um invasor pode modificar os dados serializados para incluir tipos inesperados para injetar objetos com efeitos colaterais mal-intencionados.|
|[CA2311: Não desserializar sem definir primeiro NetDataContractSerializer.Binder](ca2311.md)|Desserializadores inseguros são vulneráveis ao desserializar dados não confiáveis. Um invasor pode modificar os dados serializados para incluir tipos inesperados para injetar objetos com efeitos colaterais mal-intencionados.|
|[CA2312: Verificar se NetDataContractSerializer.Binder foi definido antes de desserializar](ca2312.md)|Desserializadores inseguros são vulneráveis ao desserializar dados não confiáveis. Um invasor pode modificar os dados serializados para incluir tipos inesperados para injetar objetos com efeitos colaterais mal-intencionados.|
|[CA2315: Não usar o desserializador inseguro ObjectStateFormatter](ca2315.md)|Desserializadores inseguros são vulneráveis ao desserializar dados não confiáveis. Um invasor pode modificar os dados serializados para incluir tipos inesperados para injetar objetos com efeitos colaterais mal-intencionados.|
|[CA2321: Não desserializar com JavaScriptSerializer usando um SimpleTypeResolver](ca2321.md)|Desserializadores inseguros são vulneráveis ao desserializar dados não confiáveis. Um invasor pode modificar os dados serializados para incluir tipos inesperados para injetar objetos com efeitos colaterais mal-intencionados.|
|[CA2322: Garantir que o JavaScriptSerializer não seja inicializado com SimpleTypeResolver antes de desserializar](ca2322.md)|Desserializadores inseguros são vulneráveis ao desserializar dados não confiáveis. Um invasor pode modificar os dados serializados para incluir tipos inesperados para injetar objetos com efeitos colaterais mal-intencionados.|
|[CA2326: Não usar valores de TypeNameHandling diferentes de None](ca2326.md)|Desserializadores inseguros são vulneráveis ao desserializar dados não confiáveis. Um invasor pode modificar os dados serializados para incluir tipos inesperados para injetar objetos com efeitos colaterais mal-intencionados.|
|[CA2327: Não usar JsonSerializerSettings não seguras](ca2327.md)|Desserializadores inseguros são vulneráveis ao desserializar dados não confiáveis. Um invasor pode modificar os dados serializados para incluir tipos inesperados para injetar objetos com efeitos colaterais mal-intencionados.|
|[CA2328: Verificar se as JsonSerializerSettings são seguras](ca2328.md)|Desserializadores inseguros são vulneráveis ao desserializar dados não confiáveis. Um invasor pode modificar os dados serializados para incluir tipos inesperados para injetar objetos com efeitos colaterais mal-intencionados.|
|[CA2329: Não desserializar com JsonSerializer usando uma configuração não segura](ca2329.md)|Desserializadores inseguros são vulneráveis ao desserializar dados não confiáveis. Um invasor pode modificar os dados serializados para incluir tipos inesperados para injetar objetos com efeitos colaterais mal-intencionados.|
|[CA2330: Verificar se o JsonSerializer tem uma configuração segura durante a desserialização](ca2330.md)|Desserializadores inseguros são vulneráveis ao desserializar dados não confiáveis. Um invasor pode modificar os dados serializados para incluir tipos inesperados para injetar objetos com efeitos colaterais mal-intencionados.|
|[CA2350: verifique se a entrada do DataTable.ReadXml() é confiável](ca2350.md)|Ao desserializar um <xref:System.Data.DataTable> com uma entrada não confiável, um invasor pode criar uma entrada mal-intencionada para executar um ataque de negação de serviço. Pode haver vulnerabilidades de execução remota de código desconhecido.|
|[CA2351: verifique se a entrada do DataSet.ReadXml() é confiável](ca2351.md)|Ao desserializar um <xref:System.Data.DataSet> com uma entrada não confiável, um invasor pode criar uma entrada mal-intencionada para executar um ataque de negação de serviço. Pode haver vulnerabilidades de execução remota de código desconhecido.|
|[CA2352: DataSet ou DataTable não seguros no tipo serializável podem ser vulneráveis a ataques de execução de código remoto](ca2352.md)|Uma classe ou estrutura marcada com <xref:System.SerializableAttribute> contém um <xref:System.Data.DataSet> <xref:System.Data.DataTable> campo ou propriedade, e não tem um <xref:System.CodeDom.Compiler.GeneratedCodeAttribute> .|
|[CA2353: DataSet ou DataTable não seguros no tipo serializável](ca2353.md)|Uma classe ou struct marcada com um atributo de serialização XML ou um atributo de contrato de dados contém um <xref:System.Data.DataSet> <xref:System.Data.DataTable> campo ou propriedade.|
|[CA2354: DataSet ou DataTable não seguros no grafo de objetos desserializados podem ser vulneráveis a ataques de execução de código remoto](ca2354.md)|A desserialização com uma <xref:System.Runtime.Serialization.IFormatter?displayProperty=nameWithType> serializada e o grafo de objeto do tipo convertido podem incluir um <xref:System.Data.DataSet> ou <xref:System.Data.DataTable> .|
|[CA2355: DataSet ou DataTable não seguros no grafo de objetos desserializados](ca2355.md)|Desserializando quando o grafo de objeto do tipo convertido ou especificado pode incluir um <xref:System.Data.DataSet> ou <xref:System.Data.DataTable> .|
|[CA2356: DataSet não seguro ou DataTable no grafo de objeto desserializado da Web](ca2356.md)|Um método com um <xref:System.Web.Services.WebMethodAttribute?displayProperty=nameWithType> ou <xref:System.ServiceModel.OperationContractAttribute?displayProperty=nameWithType> tem um parâmetro que pode fazer referência a um <xref:System.Data.DataSet> ou <xref:System.Data.DataTable> .|
|[CA2361: verifique se a classe gerada automaticamente que contém DataSet.ReadXml() não é usada quando os dados não são confiáveis](ca2361.md)|Ao desserializar um <xref:System.Data.DataSet> com uma entrada não confiável, um invasor pode criar uma entrada mal-intencionada para executar um ataque de negação de serviço. Pode haver vulnerabilidades de execução remota de código desconhecido.|
|[CA2362: DataSet ou DataTable não seguros em um tipo serializável gerado automaticamente podem ser vulneráveis a ataques de execução remota de código](ca2362.md)|Ao desserializar a entrada não confiável com <xref:System.Runtime.Serialization.Formatters.Binary.BinaryFormatter> o e o grafo de objeto desserializado contiver um <xref:System.Data.DataSet> ou <xref:System.Data.DataTable> , um invasor poderá criar uma carga mal-intencionada para executar um ataque de execução remota de código.|
|[CA3001: Examinar código quanto a vulnerabilidades de injeção de SQL](ca3001.md)|Ao trabalhar com comandos de entrada e SQL não confiáveis, lembre-se dos ataques de injeção de SQL. Um ataque de injeção de SQL pode executar comandos SQL mal-intencionados, comprometendo a segurança e a integridade do seu aplicativo.|
|[CA3002: Examinar código quanto a vulnerabilidades de XSS](ca3002.md)|Ao trabalhar com entrada não confiável de solicitações da Web, tenha cuidado com ataques XSS (scripts entre sites). Um ataque XSS injeta entrada não confiável em saída HTML bruta, permitindo que o invasor execute scripts mal-intencionados ou modifique conteúdo de forma mal-intencionada em sua página da Web.|
|[CA3003: Examinar código quanto a vulnerabilidades de injeção de caminho](ca3003.md)|Ao trabalhar com entrada não confiável de solicitações da Web, lembre-se de usar a entrada controlada pelo usuário ao especificar caminhos para arquivos.|
|[CA3004: Examinar código quanto a vulnerabilidades de divulgação de informações](ca3004.md)|A divulgação de informações de exceção dá aos invasores insights sobre os internos do seu aplicativo, o que pode ajudar os invasores a encontrar outras vulnerabilidades a serem exploradas.|
|[CA3006: Examinar código quanto a vulnerabilidades de injeção de comando de processo](ca3006.md)|Ao trabalhar com entrada não confiável, lembre-se dos ataques de injeção de comando. Um ataque de injeção de comando pode executar comandos mal-intencionados no sistema operacional subjacente, comprometendo a segurança e a integridade do servidor.|
|[CA3007: Examinar código quanto a vulnerabilidades de redirecionamento aberto](ca3007.md)|Ao trabalhar com entrada não confiável, lembre-se de vulnerabilidades de redirecionamento abertas. Um invasor pode explorar uma vulnerabilidade de redirecionamento aberto para usar seu site para dar a aparência de uma URL legítima, mas redirecionar um visitante dessuspeito para um phishing ou outra página da Web mal-intencionada.|
|[CA3008: Examinar código quanto a vulnerabilidades de injeção de XPath](ca3008.md)|Ao trabalhar com entrada não confiável, lembre-se de ataques de injeção de XPath. A construção de consultas XPath usando a entrada não confiável pode permitir que um invasor manipule a consulta de forma mal-intencionada para retornar um resultado indesejado e possivelmente divulgar o conteúdo do XML consultado.|
|[CA3009: Examinar código quanto a vulnerabilidades de injeção de XML](ca3009.md)|Ao trabalhar com entrada não confiável, lembre-se de ataques de injeção de XML.|
|[CA3010: Examinar código quanto a vulnerabilidades de injeção de XAML](ca3010.md)|Ao trabalhar com entrada não confiável, lembre-se dos ataques de injeção XAML. XAML é uma linguagem de marcação que representa diretamente a instanciação e execução de objetos. Isso significa que os elementos criados em XAML podem interagir com recursos do sistema (por exemplo, acesso à rede e e/s do sistema de arquivos).|
|[CA3011: Examinar código quanto a vulnerabilidades de injeção de DLL](ca3011.md)|Ao trabalhar com uma entrada não confiável, lembre-se de carregar código não confiável. Se o seu aplicativo Web carregar código não confiável, um invasor poderá injetar DLLs mal-intencionadas em seu processo e executar código mal-intencionado.|
|[CA3012: Examinar código quanto a vulnerabilidades de injeção de regex](ca3012.md)|Ao trabalhar com entrada não confiável, lembre-se dos ataques de injeção de Regex. Um invasor pode usar a injeção de Regex para modificar uma expressão regular de forma mal-intencionada, para fazer com que o Regex coincida com resultados indesejados ou para fazer com que o Regex consuma CPU excessiva, resultando em um ataque de negação de serviço.|
|[CA3061: Não adicionar esquema por URL](ca3061.md)|Não use a sobrecarga não segura do método Add, pois isso pode causar referências externas perigosas.|
|[CA3075: Processamento de DTD não seguro](ca3075.md)|Se você usar instâncias DTDProcessing inseguras ou referenciar fontes externas de entidade, o analisador poderá aceitar entrada não confiável e divulgar informações confidenciais a invasores.|
|[CA3076: Execução de script XSLT não seguro](ca3076.md)|Se você executar a XSLT (Extensible StyleSheet Language Transformations) em aplicativos .NET de forma insegura, o processador poderá resolver referências de URI não confiáveis que poderiam divulgar informações confidenciais para invasores, levando à negação de serviço e a ataques entre sites.|
|[CA3077: Processamento não seguro no design de API, no documento XML e no leitor de texto XML](ca3077.md)|Ao criar uma API derivada de XMLDocument e XMLTextReader, lembre-se de DtdProcessing. Usar instâncias DTDProcessing inseguras ao referenciar ou resolver fontes de entidade externas ou definir valores inseguros no XML pode levar à divulgação de informações.|
|[CA3147: Marcar manipuladores de verbo com ValidateAntiForgeryToken](ca3147.md)|Ao criar um controlador MVC ASP.NET, lembre-se de ataques de solicitação entre sites forjado. Um ataque de falsificação de solicitação entre sites pode enviar solicitações mal-intencionadas de um usuário autenticado para o controlador MVC ASP.NET.|
|[CA5350: Não usar algoritmos de criptografia fracos](ca5350.md)|Algoritmos de criptografia fracos e funções de hash são usados hoje por vários motivos, mas eles não devem ser usados para garantir a confidencialidade ou a integridade dos dados que eles protegem. Essa regra é disparada quando encontra algoritmos TripleDES, SHA1 ou RIPEMD160 no código.|
|[CA5351: não use algoritmos de criptografia desfeitos](ca5351.md)|Os algoritmos de criptografia desfeitos não são considerados seguros e seu uso deve ser altamente desencorajado. Essa regra é disparada quando encontra o algoritmo de hash MD5 ou os algoritmos de criptografia DES ou RC2 no código.|
|[CA5358: Não usar modos de criptografia não seguros](ca5358.md)|Não usar modos de criptografia não seguros|
|[CA5359: Não desabilitar a validação de certificado](ca5359.md)|Um certificado pode ajudar a autenticar a identidade do servidor. Os clientes devem validar o certificado do servidor para garantir que as solicitações sejam enviadas ao servidor pretendido. Se o ServerCertificateValidationCallback sempre retornar `true` , qualquer certificado passará na validação.|
|[CA5360: Não chamar métodos perigosos durante a desserialização](ca5360.md)|A desserialização insegura é uma vulnerabilidade que ocorre quando dados não confiáveis são usados para proutilizar a lógica de um aplicativo, causarem um ataque de negação de serviço (DoS) ou até mesmo executar um código arbitrário quando ele estiver desserializado. Frequentemente, é possível que usuários mal-intencionados abusam esses recursos de desserialização quando o aplicativo estiver desserializando dados não confiáveis que estão sob seu controle. Especificamente, invoque métodos perigosos no processo de desserialização. Ataques de desserialização inseguros com êxito podem permitir que um invasor execute ataques, como ataques de DoS, desvios de autenticação e execução remota de código.|
|[CA5361: não desabilitar o uso do SChannel de criptografia forte](ca5361.md)|`Switch.System.Net.DontEnableSchUseStrongCrypto`A configuração para `true` enfraquece a criptografia usada em conexões TLS (segurança da camada de transporte) de saída. A criptografia mais fraca pode comprometer a confidencialidade da comunicação entre o aplicativo e o servidor, tornando mais fácil para os invasores bisbilhotarem dados confidenciais.|
|[CA5362: Ciclo de referência potencial no grafo de objetos desserializado](ca5362.md)|Se estiver desserializando dados não confiáveis, qualquer código que processe o grafo de objeto desserializado precisará manipular os ciclos de referência sem entrar em loops infinitos. Isso inclui o código que faz parte de um retorno de chamada de desserialização e o código que processa o grafo de objeto após a desserialização ser concluída. Caso contrário, um invasor pode executar um ataque de negação de serviço com dados mal-intencionados que contenham um ciclo de referência.|
|[CA5363: Não desabilitar a validação de solicitação](ca5363.md)|A validação de solicitação é um recurso no ASP.NET que examina as solicitações HTTP e determina se elas contêm conteúdo potencialmente perigoso que pode levar a ataques de injeção, incluindo scripts entre sites.|
|[CA5364: Não use protocolos de segurança preteridos](ca5364.md)|A segurança de camada de transporte (TLS) protege a comunicação entre computadores, mais comumente com HTTPS (Hypertext Transfer Protocol Secure). Versões de protocolo mais antigas do TLS são menos seguras do que o TLS 1,2 e o TLS 1,3 e têm mais probabilidade de ter novas vulnerabilidades. Evite versões de protocolo mais antigas para minimizar o risco.|
|[CA5365: Não desabilitar a verificação de cabeçalho HTTP](ca5365.md)|A verificação de cabeçalho HTTP permite a codificação do retorno de carro e dos caracteres de nova linha, \r e \n, que são encontrados nos cabeçalhos de resposta. Essa codificação pode ajudar a evitar ataques de injeção que exploram um aplicativo que ecoa dados não confiáveis contidos no cabeçalho.|
|[CA5366: Usar XmlReader para XML da leitura do conjunto de dados](ca5366.md)|Usar um <xref:System.Data.DataSet> para ler XML com dados não confiáveis pode carregar referências externas perigosas, que devem ser restringidas usando um <xref:System.Xml.XmlReader> com um resolvedor seguro ou com o processamento de DTD desabilitado.|
|[CA5367: Não serializar tipos com campos de ponteiro](ca5367.md)|Esta regra verifica se há uma classe serializável com um campo ou propriedade de ponteiro. Os membros que não podem ser serializados podem ser um ponteiro, como membros estáticos ou campos marcados com <xref:System.NonSerializedAttribute> .|
|[CA5368: Definir ViewStateUserKey para as classes derivadas da página](ca5368.md)|Definir a <xref:System.Web.UI.Page.ViewStateUserKey> propriedade pode ajudá-lo a evitar ataques em seu aplicativo, permitindo que você atribua um identificador à variável de estado de exibição para usuários individuais para que os invasores não possam usar a variável para gerar um ataque. Caso contrário, haverá vulnerabilidades para falsificação de solicitação entre sites.|
|[CA5369: Usar o XmlReader para desserializar](ca5369.md)|O processamento de esquemas XML e DTD não confiáveis pode permitir o carregamento de referências externas perigosas, que devem ser restringidas com o uso de um XmlReader com um resolvedor seguro ou com o processamento de esquema embutido XML e DTD desabilitado.|
|[CA5370: Usar o XmlReader para validar o leitor](ca5370.md)|O processamento de esquemas XML e DTD não confiáveis pode permitir o carregamento de referências externas perigosas. Esse carregamento perigoso pode ser restringido usando um XmlReader com um resolvedor seguro ou com o processamento de esquema embutido XML e DTD desabilitado.|
|[CA5371: Usar o XmlReader para a leitura do esquema](ca5371.md)|O processamento de esquemas XML e DTD não confiáveis pode permitir o carregamento de referências externas perigosas. O uso de um XmlReader com um resolvedor seguro ou com o processamento de esquema embutido XML e DTD desabilitado restringe isso.|
|[CA5372: Usar o XmlReader para o XPathDocument](ca5372.md)|O processamento de XML de dados não confiáveis pode carregar referências externas perigosas, que podem ser restringidas usando um XmlReader com um resolvedor seguro ou com o processamento de DTD desabilitado.|
|[CA5373: Não usar a função de derivação de chave obsoleta](ca5373.md)|Essa regra detecta a invocação de métodos de derivação de chave fraca <xref:System.Security.Cryptography.PasswordDeriveBytes?displayProperty=fullName> e `Rfc2898DeriveBytes.CryptDeriveKey` . <xref:System.Security.Cryptography.PasswordDeriveBytes?displayProperty=fullName> usou um algoritmo fraco de PBKDF1.|
|[CA5374: Não usar XslTransform](ca5374.md)|Essa regra verifica se <xref:System.Xml.Xsl.XslTransform?displayProperty=nameWithType> é criada uma instância no código. <xref:System.Xml.Xsl.XslTransform?displayProperty=nameWithType> Agora é obsoleto e não deve ser usado.|
|[CA5375: Não usar a assinatura de acesso compartilhado da conta](ca5375.md)|Uma SAS de conta pode delegar acesso a operações de leitura, gravação e exclusão em contêineres de BLOB, tabelas, filas e compartilhamentos de arquivos que não são permitidos com uma SAS de serviço. No entanto, ele não dá suporte a políticas em nível de contêiner e tem menos flexibilidade e controle sobre as permissões concedidas. Depois que os usuários mal-intencionados o obtiverem, sua conta de armazenamento será comprometida facilmente.|
|[CA5376: Usar SharedAccessProtocol HttpsOnly](ca5376.md)|SAS são dados confidenciais que não podem ser transportados em texto sem formatação em HTTP.|
|[CA5377: Usar política de acesso no nível de contêiner](ca5377.md)|Uma política de acesso no nível de contêiner pode ser modificada ou revogada a qualquer momento. Ele fornece maior flexibilidade e controle sobre as permissões concedidas.|
|[CA5378: Não desabilite ServicePointManagerSecurityProtocols](ca5378.md)|Configuração `Switch.System.ServiceModel.DisableUsingServicePointManagerSecurityProtocols` para `true` limita as conexões de TLS (segurança de camada de transporte) do Windows Communication Framework (WCF) usando o TLS 1,0. Essa versão do TLS será preterida.|
|[CA5379: Verifique se o algoritmo da função de derivação de chave é suficientemente forte](ca5379.md)|A <xref:System.Security.Cryptography.Rfc2898DeriveBytes> classe assume como padrão o uso do <xref:System.Security.Cryptography.HashAlgorithmName.SHA1> algoritmo. Você deve especificar o algoritmo de hash a ser usado em algumas sobrecargas do construtor com <xref:System.Security.Cryptography.HashAlgorithmName.SHA256> ou superior. Observe <xref:System.Security.Cryptography.Rfc2898DeriveBytes.HashAlgorithm> que Property tem apenas um `get` acessador e não tem um `overriden` modificador.|
|[CA5380: Não adicionar certificados ao repositório raiz](ca5380.md)|Essa regra detecta o código que adiciona um certificado ao repositório de certificados das autoridades de certificação raiz confiáveis. Por padrão, o repositório de certificados de autoridades de certificação raiz confiáveis é configurado com um conjunto de CAs públicas que atendem aos requisitos do programa de certificado raiz da Microsoft.|
|[CA5381: Verificar que os certificados não sejam adicionados ao repositório raiz](ca5381.md)|Essa regra detecta o código que potencialmente adiciona um certificado ao repositório de certificados de autoridades de certificação raiz confiáveis. Por padrão, o repositório de certificados de autoridades de certificação raiz confiáveis é configurado com um conjunto de CAs (autoridades de certificação) públicas que atendem aos requisitos do Microsoft Root Certificate Program.|
|[CA5382: Usar cookies seguros no ASP.NET Core](ca5382.md)|Os aplicativos disponíveis via HTTPS devem usar cookies seguros, que indicam ao navegador que o cookie só deve ser transmitido usando TLS (Transport Layer Security).|
|[CA5383: Garantir o uso de cookies seguros no ASP.NET Core](ca5383.md)|Os aplicativos disponíveis via HTTPS devem usar cookies seguros, que indicam ao navegador que o cookie só deve ser transmitido usando TLS (Transport Layer Security).|
|[CA5384: Não usar o DSA (algoritmo de assinatura digital)](ca5384.md)|O DSA é um algoritmo de criptografia assimétrica fraco.|
|[CA5385: Usar o algoritmo RSA (Rivest–Shamir–Adleman) com um tamanho de chave suficiente](ca5385.md)|Uma chave RSA inferior a 2048 bits é mais vulnerável a ataques de força bruta.|
|[CA5386: Evitar codificar o valor SecurityProtocolType](ca5386.md)|A segurança de camada de transporte (TLS) protege a comunicação entre computadores, mais comumente com HTTPS (Hypertext Transfer Protocol Secure). As versões de protocolo TLS 1,0 e TLS 1,1 foram preteridas, enquanto TLS 1,2 e TLS 1,3 são atuais. No futuro, o TLS 1,2 e o TLS 1,3 podem ser preteridos. Para garantir que seu aplicativo permaneça seguro, evite codificar uma versão de protocolo e ter como destino pelo menos .NET Framework v 4.7.1.|
|[CA5387: Não usar a função de derivação de chaves fraca com uma contagem de iteração insuficiente](ca5387.md)|Esta regra verifica se uma chave criptográfica foi gerada por <xref:System.Security.Cryptography.Rfc2898DeriveBytes> com uma contagem de iteração inferior a 100.000. Uma contagem de iteração mais alta pode ajudar a mitigar contra ataques de dicionário que tentam adivinhar a chave de criptografia gerada.|
|[CA5388: Assegurar uma contagem de iteração suficiente ao usar a função de derivação de chaves fraca](ca5388.md)|Esta regra verifica se uma chave de criptografia foi gerada pelo <xref:System.Security.Cryptography.Rfc2898DeriveBytes> com uma contagem de iteração que pode ser menor que 100.000. Uma contagem de iteração mais alta pode ajudar a mitigar contra ataques de dicionário que tentam adivinhar a chave de criptografia gerada.|
|[CA5389: Não adicionar o caminho do item de arquivo ao caminho do sistema de arquivos de destino](ca5389.md)|O caminho do arquivo pode ser relativo e pode levar ao acesso do sistema de arquivos fora do caminho de destino do sistema de arquivos esperado, levando a alterações de configuração mal-intencionadas e à execução remota de código por meio da técnica de Lay-and-wait.|
|[CA5390: Não embutir a chave de criptografia em código](ca5390.md)|Para que um algoritmo simétrico seja bem-sucedido, a chave secreta deve ser conhecida somente pelo remetente e pelo destinatário. Quando uma chave é embutida em código, ela é facilmente descoberta. Mesmo com binários compilados, é fácil para usuários mal-intencionados extraí-lo. Depois que a chave privada for comprometida, o texto cifrado poderá ser descriptografado diretamente e não será mais protegido.|
|[CA5391: Usar tokens antifalsificação em controladores MVC do ASP.NET Core](ca5391.md)|Manipular uma `POST` `PUT` solicitação,, `PATCH` ou `DELETE` sem validar um token de antifalsificação pode estar vulnerável a ataques de solicitação entre sites forjada. Um ataque de falsificação de solicitação entre sites pode enviar solicitações mal-intencionadas de um usuário autenticado para seu controlador ASP.NET Core MVC.|
|[CA5392: Usar o atributo DefaultDllImportSearchPaths para P/Invokes](ca5392.md)|Por padrão, as funções P/Invoke usam a <xref:System.Runtime.InteropServices.DllImportAttribute> investigação de um número de diretórios, incluindo o diretório de trabalho atual para a biblioteca carregar. Isso pode ser um problema de segurança para determinados aplicativos, levando ao seqüestro de DLL.|
|[CA5393: Não usar o valor DllImportSearchPath não seguro](ca5393.md)|Pode haver uma DLL mal-intencionada nos diretórios de pesquisa padrão de DLL e no assembly. Ou, dependendo de onde o aplicativo é executado, pode haver uma DLL mal-intencionada no diretório do aplicativo.|
|[CA5394: Não usar aleatoriedade não segura](ca5394.md)|O uso de um gerador de números pseudo aleatórios criptograficamente fraco pode permitir que um invasor preveja qual valor de segurança será gerado.|
|[CA5395: Ignorar o atributo HttpVerb para métodos de ação](ca5395.md)|Todos os métodos de ação que criam, editam, excluem ou modificam os dados precisam ser protegidos com o atributo antifalsificação de ataques de falsificação de solicitação entre sites. A execução de uma operação GET deve ser uma operação segura que não tenha efeitos colaterais e não modifique seus dados persistentes.|
|[CA5396: Definir HttpOnly como true para HttpCookie](ca5396.md)|Como uma medida de defesa profunda, verifique se os cookies HTTP sensíveis à segurança estão marcados como HttpOnly. Isso indica que os navegadores da Web devem impedir que os scripts acessem os cookies. Scripts maliciosos injetados são uma maneira comum de roubar cookies.|
|[CA5397: Não usar valores de SslProtocols preteridos](ca5397.md)|A segurança de camada de transporte (TLS) protege a comunicação entre computadores, mais comumente com HTTPS (Hypertext Transfer Protocol Secure). Versões de protocolo mais antigas do TLS são menos seguras do que o TLS 1,2 e o TLS 1,3 e têm mais probabilidade de ter novas vulnerabilidades. Evite versões de protocolo mais antigas para minimizar o risco.|
|[CA5398: Evitar valores de SslProtocols fixos](ca5398.md)|A segurança de camada de transporte (TLS) protege a comunicação entre computadores, mais comumente com HTTPS (Hypertext Transfer Protocol Secure). As versões de protocolo TLS 1,0 e TLS 1,1 foram preteridas, enquanto TLS 1,2 e TLS 1,3 são atuais. No futuro, o TLS 1,2 e o TLS 1,3 podem ser preteridos. Para garantir que seu aplicativo permaneça seguro, evite codificar uma versão de protocolo.|
|[CA5399: Desabilitar definitivamente a verificação da lista de certificados revogados do HttpClient](ca5399.md)|Um certificado revogado não é mais confiável. Ele pode ser usado por invasores passando dados mal-intencionados ou roubando dados confidenciais na comunicação HTTPS.|
|[CA5400: Certificar-se de que a verificação da lista de certificados revogados do HttpClient não está desabilitada](ca5400.md)|Um certificado revogado não é mais confiável. Ele pode ser usado por invasores passando dados mal-intencionados ou roubando dados confidenciais na comunicação HTTPS.|
|[CA5401: Não usar CreateEncryptor com IV não padrão](ca5401.md)|A criptografia simétrica sempre deve usar um vetor de inicialização não reproduzível para evitar ataques de dicionário.|
|[CA5402: Usar CreateEncryptor com o IV padrão](ca5402.md)|A criptografia simétrica sempre deve usar um vetor de inicialização não reproduzível para evitar ataques de dicionário.|
|[CA5403: Não embutir o certificado em código](ca5403.md)|O `data` `rawData` parâmetro ou de um <xref:System.Security.Cryptography.X509Certificates.X509Certificate> Construtor ou é embutido <xref:System.Security.Cryptography.X509Certificates.X509Certificate2> em código.|
